package org.tron.service;

import java.util.Arrays;
import java.util.Objects;
import java.util.TimeZone;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import lombok.extern.slf4j.Slf4j;
import org.apache.kafka.clients.consumer.ConsumerRecord;
import org.apache.kafka.clients.consumer.ConsumerRecords;
import org.json.simple.JSONObject;
import org.json.simple.JSONValue;
import org.tron.common.config.Args;
import org.tron.common.exception.RpcConnectException;
import org.tron.common.utils.WalletUtil;
import org.tron.db.TransactionExtentionStore;
import org.tron.protos.Sidechain.TaskEnum;
import org.tron.service.check.TransactionExtensionCapsule;
import org.tron.service.eventactuator.Actuator;
import org.tron.service.eventactuator.EventActuatorFactory;
import org.tron.service.kafka.KfkConsumer;
import org.tron.service.task.InitTask;
import org.tron.service.task.TxExtensionTask;

/*
 * This Java source file was generated by the Gradle 'init' task.
 */
@Slf4j(topic = "app")
public class App {

  private static int fixedThreads = 5;

  private static ExecutorService executor;

  private static KfkConsumer kfkConsumer;

  public static void main(String[] args) {
    TimeZone.setDefault(TimeZone.getTimeZone("UTC"));
    logger.info("start...");
    Args arg = Args.getInstance();
    try {
      arg.setParam(args);
    } catch (RpcConnectException e) {
      logger.error("failed to get sun token when setParam", e);
      System.exit(1);
    }

    (new InitTask(10)).batchProcessTxInDb();

    TransactionExtentionStore store = TransactionExtentionStore.getInstance();
    String mainGateway = WalletUtil.encode58Check(arg.getSidechainGateway());
    String sideGateway = WalletUtil.encode58Check(arg.getSidechainGateway());
    executor = Executors.newFixedThreadPool(fixedThreads);
    kfkConsumer = new KfkConsumer(Args.getInstance().getMainchainKafka(), "Oracle",
        Arrays.asList("contractevent"));

    // ChainTask sideChainTask = new ChainTask(TaskEnum.SIDE_CHAIN,
    //     WalletUtil.encode58Check(arg.getSidechainGateway()),
    //     Args.getInstance().getSidechainKafka(), fixedThreads);
    // ChainTask mainChainTask = new ChainTask(TaskEnum.MAIN_CHAIN,
    //     WalletUtil.encode58Check(arg.getMainchainGateway()),
    //     Args.getInstance().getMainchainKafka(), fixedThreads);
    // sideChainTask.start();
    // mainChainTask.start();

    processEvent(store, mainGateway, sideGateway);
    return;

  }

  private static void processEvent(TransactionExtentionStore store, String mainGateway,
      String sideGateway) {
    for (; ; ) {
      ConsumerRecords<String, String> record = kfkConsumer.getRecord();
      for (ConsumerRecord<String, String> key : record) {
        JSONObject obj = (JSONObject) JSONValue.parse(key.value());
        if (Objects.isNull(obj.get("contractAddress"))) {
          kfkConsumer.commit();
          continue;
        }
        Actuator eventActuator;
        if (obj.get("contractAddress").equals(mainGateway)) {
          eventActuator = EventActuatorFactory.CreateActuator(TaskEnum.MAIN_CHAIN, obj);
        } else if (obj.get("contractAddress").equals(sideGateway)) {
          eventActuator = EventActuatorFactory.CreateActuator(TaskEnum.SIDE_CHAIN, obj);
        } else {
          //Unrelated contract address
          kfkConsumer.commit();
          continue;
        }
        if (Objects.isNull(eventActuator)) {
          //Unrelated contract event
          kfkConsumer.commit();
          continue;
        }
        TransactionExtensionCapsule txExtensionCapsule = eventActuator
            .getTransactionExtensionCapsule();
        if (Objects.isNull(txExtensionCapsule)) {
          kfkConsumer.commit();
          continue;
        }
        byte[] txIdBytes = txExtensionCapsule.getTransactionIdBytes();
        if (!store.exist(txIdBytes)) {
          store.putData(txIdBytes, txExtensionCapsule.getData());
        }
        kfkConsumer.commit();
        executor.execute(new TxExtensionTask(txExtensionCapsule));
      }
    }
  }
}
